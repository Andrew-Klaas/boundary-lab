slug: klaas-zt-sandbox
id: mjhgbj3a3yyb
version: 0.0.1
type: track
title: WIP-Application Security with Vault, Consul, & Boundary
teaser: Leverage the HashiCorp stack to secure application infrastructure (ZT)
description: |-
  This workshop will provide hands on expreicne securing an application stack utilizing several tools from the HashiCorp suite.
  Vault will be utilized to secure application credentails and customer data. Consul will enforce mTLS and network policy. Finally, Boundary will secure access managemnt for human users like DBAs System Admins.
icon: ""
tags: []
owner: hashicorp
developers:
- aklaas@hashicorp.com
private: true
published: false
challenges:
- slug: 01-vault-aws-authentication
  id: oj6ydqgrfeob
  type: challenge
  title: Vault's AWS authentication method
  teaser: Authenticate applications to Vault using AWS IAM.
  notes:
  - type: text
    contents: |-
      The challenge of "Secure Introduction" or how to introduce an authentication token to applications is often one of the most difficult challenges in application & infrastructure deployments

      "Auth methods" are the components in Vault that perform authentication and are responsible for assigning identity and a set of policies to a user. Having multiple auth methods enables you to use an auth method that makes the most sense for your use case of Vault and your organization.

      In our example deployment, we will use the AWS auth method to authenticate our golang application.
  assignment: |-
    First, we need to authenticate Vault as an admin user. This will set your vault token at "~/.vault-token".
    ```
    vault login -method=userpass username=vault password=vault
    ```
    Once authenticated, view currently mounted auth methods
    ```
    vault auth list
    ```
    Note, the AWS auth method has already been mounted for you. You would use "Vault auth enable aws" to mount it yourself.

    The AWS auth method's documentation can be found here: https://www.vaultproject.io/docs/auth/aws

    Next, read the AWS auth mount config.
    ```
    vault read auth/aws/config/client
    ```
    The mount's already been configured for you as well.
    To do so in your own environment, you need to configure the auth method with suitable AWS credentials to perform actions on IAM Users.
    Our recommended AWS policy is here: https://www.vaultproject.io/docs/auth/aws#recommend

    You DO NOT need to run this step.
    ```
    vault write auth/aws/config/client \
      access_key=$AWS_ACCESS_KEY_ID \
      secret_key=$AWS_SECRET_ACCESS_KEY
    ```
    Next, configure a role for our application. The argument are explained in detail here: https://www.vaultproject.io/api/auth/aws#create-role

    The role can be used to set time to lives for tokens, assosciate policies for Vault access, and set parameters on allowed IAM prinicpal ARNs.
    ```
    vault write auth/aws/role/my-role-iam \
      auth_type=iam \
      bound_iam_principal_arn=arn:aws:iam::$AWS_ACCOUNT_ID:* \
      policies=go-app \
      token_ttl=30m \
      token_max_ttl=30m
    ```
    Check your created role.
    ```
    vault read auth/aws/role/my-role-iam
    ```
    Test the login via CLI.

    ```
    vault login -method=aws role=my-role-iam
    ```
    So, how does our application perform this login? Vault programming libraries allow you to natively integrate your application for improved security.

    By having your applciation call Vault directly, you can ensure that credentials only live in memory and not on disk or envirnoment variables.

    Lets take a look at lines X-Y in the "Goapp - Vault code" tab. This is the code used by our application to login to Vault's AWS auth method.
    ```
    cat /tmp/aws-vault-go-demo-tokenization/config/db.go
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  - title: Goapp - Vault code
    type: code
    hostname: hashistack-server
    path: /tmp/aws-vault-go-demo-tokenization/config/db.go
  difficulty: basic
  timelimit: 60000
- slug: 02-vault-dynamic-secrets
  id: kqyrabasn1cy
  type: challenge
  title: Vault dynamic secrets
  teaser: Create least priviledge & just-in-time database credentials
  notes:
  - type: text
    contents: |-
      The database secrets engine generates database credentials dynamically based on configured roles. It works with a number of different databases through a plugin interface. There are a number of built-in database types, and an exposed framework for running custom database types for extendability. This means that services that need to access a database no longer need to hardcode credentials: they can request them from Vault, and use Vault's leasing mechanism to more easily roll keys. These are referred to as "dynamic roles" or "dynamic secrets".
      Since every service is accessing the database with unique credentials, it makes auditing much easier when questionable data access is discovered. You can track it down to the specific instance of a service based on the SQL username.
      Vault makes use of its own internal revocation system to ensure that users become invalid within a reasonable time of the lease expiring.
  assignment: |-
    First, log back into Vault as our admin user.
    ```
    vault login -method=userpass username=vault password=vault
    ```
    List currently mounted secret engines
    ```
    vault secrets list
    ```
    The PostgreSQL database secret engine has already been mounted and configure for you
    ```
    vault read database/config/my-postgresql-database
    ```
    To configure the secret engine we needed to give Vault admin level credentials that enable creation and deletion of users.
    We also set the connection_url in this setup so Vault can locate the database.

    You DO NOT need to run this command as hit has been done already.
    ```
    vault write database/config/my-postgresql-database \
      plugin_name=postgresql-database-plugin \
      allowed_roles="my-role, vault_go_demo" \
      connection_url="postgresql://{{username}}:{{password}}@postgres.service.consul:5432/vault_go_demo?sslmode=disable" \
      username="postgres" \
      password="password"
    ```
    Next we configure a secret engine role. In this step we can customize the creation_statements used by Vault for creating users.
    creation_statements are used to grant different permissions for users to read, write, etc. from databases.
    We also set the database crednetial time-to-live and max time-to-live. After the TTL expires, the credential will be deleted from the databasde by Vault unless your applicaiton renews it.
    ```
    vault write database/roles/vault_go_demo \
      db_name=my-postgresql-database \
      creation_statements="CREATE ROLE \"{{name}}\" WITH LOGIN PASSWORD '{{password}}' VALID UNTIL '{{expiration}}'; \
      ALTER USER \"{{name}}\" WITH SUPERUSER;" \
      default_ttl="1h" \
      max_ttl="24h"
    ```
    Test the secret engine.
    ```
    vault read database/creds/vault_go_demo
    ```
    You should see Vault's dynamically generated username and password for PostreSQL. Every read to this secret engine will create a unique credential.
    As you can see, this improves auditability of applications as now every instance has a unique credential.
    The lead_duration specificies how long the credential will last until Vault deletes its from the database. Your application can continuously renew this credential up until the configures max TTL.
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 60000
- slug: 03-vault-tokenization-eaas
  id: jqwymtoguy41
  type: challenge
  title: Vault Transform Secret engine (Tokenization/EaaS)
  teaser: Protect critical customer data via tokenization. (PCI Compliance)
  notes:
  - type: text
    contents: The Transform secrets engine handles secure data transformation and
      tokenization against the provided secrets. Transformation methods encompass
      NIST vetted cryptographic standards such as format-preserving encryption (FPE)
      via FF3-1 to encode your secrets while maintaining the data format and length.
      In addition, it can also perform pseudonymous transformations of the data through
      other means, such as masking.
  assignment: |-
    The Transform secret engine has already been mounted for you
    ```
    vault secrets list
    ```
    We first need to configure the secret engine to use tokenization.
    Our golang application will be leveraging tokenization to protect customer data and meet PCI compliance of non-repudiation.

    Lets configure a named role in Vault for our secret engine.
    ```
    vault write transform/role/vault_go_demo transformations=ssn
    ```
    Next, define a transformation. Transformations hold information about a particular transformation. It contains information about the type of transformation that we want to perform, the template that it should use for value detection, and other transformation-specific values such as the tweak source or the masking character to use.

    ```
    vault write transform/transformations/tokenization/ssn \
      allowed_roles=vault_go_demo \
      max_ttl=24h
    ```
    Verify the role.
    ```
    vault read transform/role/vault_go_demo
    ```
    Verify the transformation
    ```
    vault read transform/transformations/tokenization/ssn
    ```
    Test tokenizationg (Encoding) a value.
    ```
    vault write transform/encode/vault_go_demo value=1111-2222-3333-4444 transformation=ssn
    ```
    Next, decode the tokenized value from above.
    ```
    vault write transform/decode/vault_go_demo value=$(ENCODED_VAULT) transformation=ssn
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 60000
- slug: 04-test-app
  id: c5zycezukwae
  type: challenge
  title: Test the application
  teaser: Write an example record to the application.
  notes:
  - type: text
    contents: With our application integrated with Vault, we can now test creating
      a customer record.
  assignment: |-
    Switch to the Client 1 terminal
    ```
    systemctl start goapp
    ```
    Now test the App UI by adding a customer Record.

    Navigate to the "Add Record" button and fill in example data. Once submitted, you will be redirected to the applications view of all detokenized data.

    Next switch to the "Database View" tab. You should see that your new record's SSN has been tokenized.

    If anyone where to compromise your database, they now would be unable to reverse this data.

    Further Reading: Our application should be leveraging TLS certificates for secure connections.
    We could have integrated it with the Vault PKI secrets engine to do so: https://learn.hashicorp.com/tutorials/vault/pki-engine
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 05-consul-ui
  id: onnejylpe8tv
  type: challenge
  title: Explore the Consul UI
  teaser: Monitor Consul nodes & services via the UI.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: Explore the Consul UI Tab. Check the Nodes and Services Tabs.
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 06-consul-services
  id: kiuymimbpn9n
  type: challenge
  title: Defining Consul Services
  teaser: Create a simple service definition format to declare the availability of
    a service in the Consul catalog.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: |-
    Switch to the Client 1 terminal
    ```
    cd /etc/consul.d/
    cat consul.hcl
    ```

    ```
    cat goapp.hcl
    ```
    Switch to the Client 2 terminal
    ```
    cd /etc/consul.d/
    cat consul.hcl
    ```

    ```
    cat postgres.hcl
    ```

    ```
    consul catalog services
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 07-consul-dns
  id: 4ufy2zk3wj3d
  type: challenge
  title: Testing Consul DNS
  teaser: Use Consul DNS to locate services.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: |-
    Test Consul DNS
    ```
    dig postgres.service.consul
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 08-define-consul-intentions
  id: 978rumtsfwey
  type: challenge
  title: Defining Consul Intentions (Network Policy)
  teaser: Define access control for services via Connect and control which services
    may establish connections or make requests.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: |-
    Client 1:
    ```
    cd /etc/consul.d/
    cat goapp.hcl
    ```
    Client 2:
    ```
    cd /etc/consul.d/
    cat postgres.hcl
    ```
    ```
    cat << EOF > ~/config-intentions-postgres-deny.hcl
    Kind = "service-intentions"
    Name = "postgres"
    Sources = [
      {
        Name   = "goapp"
        Action = "deny"
      },
      # NOTE: a default catch-all based on the default ACL policy will apply to
      # unmatched connections and requests. Typically this will be DENY.
    ]
    EOF
    consul config write config-intentions-postgres-deny.hcl
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 09-test-consul-intentions
  id: xslnysgv6mzj
  type: challenge
  title: Testing Consul Intentions
  teaser: Create Deny & Allow rules for accessing Postgres.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: |-
    Client 1:
    ```
    cat << EOF > ~/config-intentions-postgres-allow.hcl
    Kind = "service-intentions"
    Name = "postgres"
    Sources = [
      {
        Name   = "goapp"
        Action = "allow"
      },
      # NOTE: a default catch-all based on the default ACL policy will apply to
      # unmatched connections and requests. Typically this will be DENY.
    ]
    EOF
    consul config write config-intentions-postgres-allow.hcl
    ```
    ```
    systemctl restart goapp
    ```
    Test the Webapp
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 10-configure-boundary-and-vault
  id: j5btwrjmcgx5
  type: challenge
  title: Configure Boundary and Vault
  teaser: Configure Vault to issue credentials for Boundary.
  notes:
  - type: text
    contents: |-
      Boundary provides a secure way to access hosts and critical systems without having to manage credentials or expose your network.

      Boundary 0.4.0 adds a Vault integration for the brokering of Vault secrets to Boundary clients via the command line and desktop clients for use in their Boundary sessions.

      This feature enables Boundary as a credential broker for infrastructure targets by binding credentials with user sessions, and surfacing those credentials during session initialization.
  assignment: |-
    First, login to Vault on using the "Server" tab
    ```
    vault login -method=userpass username=vault password=vault
    ```
    Next, we will configure Boundary using HashiCorp Terraform.
    Terraform is an open-source infrastructure as code software tool that enables you to safely and predictably create, change, and improve infrastructure.
    Change into the terraform-boundary directory where our Terraform config is stored
    ```
    cd terraform-boundary/
    cat boundary-controller-policy.hcl
    ```
    Boundary needs to lookup, renew, and revoke tokens and leases in order to broker credentials properly.

    Next, we will create a Vault token for the Boundary Server to use.

    ```
    vault policy write boundary-controller boundary-controller-policy.hcl
    vault token create \
      -no-default-policy=true \
      -policy="boundary-controller" \
      -policy="go-app" \
      -orphan=true \
      -period=20m \
      -renewable=true
    ```

    Initialize terraform and run a dry-run or plan.
    ```
    #feed token to terraform
    terraform init;
    terraform plan;
    ```
    Once satisified, apply the configuration.
    ```
    terraform apply --auto-approve;
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 11-boundary-ui
  id: nd6xsy348mhi
  type: challenge
  title: Explore the Boundary UI
  teaser: Get familiar with Boundary projects and targets.
  notes:
  - type: text
    contents: TODO
  assignment: |-
    Login to Boundary and explore the UI
    ```
    username: admin
    password: password
    ```
    Navigate to the corp_one org then to targets. Note the different targets we can access.
    Copy the Postgres_server Target. We will access this in the next challenge.
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
- slug: 12-connect-to-database
  id: v5hh6i7cg6ej
  type: challenge
  title: Test Boundary secure access management.
  teaser: Leverage Boundary to securely connect to PostgreSQL.
  notes:
  - type: text
    contents: First challenge placeholder text
  assignment: |-
    Login to Boundary and explore the UI
    ```
    export BOUNDARY_TOKEN=$(boundary authenticate password -auth-method-id ampw_1234567890 -login-name admin -password "password" -keyring-type=none -format=json | jq -r '.item.attributes.token')
    echo $BOUNDARY_TOKEN
    ```

    ```
    #Copy the postgres_server target from the corp_one org
    export POSTGRES_TARGET=ttcp_uJw5GWOygZ
    ```

    ```
    boundary targets authorize-session -id  $POSTGRES_TARGET
    ```

    ```
    boundary connect postgres -target-id $POSTGRES_TARGET --dbname vault_go_demo
    ```

    ```
    \l
    \u
    quit
    ```


    ```
    # SSH: ssh_server target (client2)
    export SSH_TARGET=
    ```

    ```
    boundary connect ssh -target-id $SSH_TARGET
    ```
  tabs:
  - title: Server
    type: terminal
    hostname: hashistack-server
  - title: App UI
    type: service
    hostname: hashistack-client-1
    port: 9090
  - title: Vault UI
    type: service
    hostname: hashistack-server
    port: 8200
  - title: Consul UI
    type: service
    hostname: hashistack-server
    port: 8500
  - title: Boundary UI
    type: service
    hostname: hashistack-server
    port: 9200
  - title: Client 1
    type: terminal
    hostname: hashistack-client-1
  - title: Client 2
    type: terminal
    hostname: hashistack-client-2
  - title: Terraform Editor
    type: code
    hostname: hashistack-server
    path: /root/terraform-boundary/main.tf
  difficulty: basic
  timelimit: 600
checksum: "6265153547198914489"
